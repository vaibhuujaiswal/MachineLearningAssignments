# -*- coding: utf-8 -*-
"""utils.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZQz15igocqh1KIMvRY7zrhtgd-_0AiK_

Part 1 of question 3 : (Designing the class)
"""

import numpy as np
import random as rand
import pandas as pd

class Dataset:
    def __init__(self, noOfDatapoints):
        self.noOfDatapoints = noOfDatapoints
    
    def get(self,add_noise):
        dataSetList = [[]]
        len = (int)((self.noOfDatapoints)/2)
        for iterations in range(0,len):
            y1 = rand.SystemRandom().uniform(-1.0,1.0)
            tempList1 = [] #for h = 0, and k = 0
            tempList2 = [] #for h = 0; and k = 3
            x1 = np.sqrt(1 - (y1 * y1))
            y2 = rand.SystemRandom().uniform(2,4)
            powerofx = pow(y2-3, 2)
            x2 = np.sqrt(1 - powerofx)
            value = rand.randint(0,1)
            if value == 1:
                x1 = -1 * x1
            if value == 0:
                x2 = -1 * x2

            if (add_noise == True):
                noise1 = np.random.normal(0,0.1)
                noise2 = np.random.normal(0,0.1)
                x2 += noise1
                x1 += noise2
                noise3 = np.random.normal(0,0.1)
                noise4 = np.random.normal(0,0.1)
                y1 += noise3
                y2 += noise4
            tempList1.append(x1)
            tempList1.append(y1)
            tempList1.append(0)
            tempList2.append(x2)
            tempList2.append(y2)
            tempList2.append(1)
            # print(tempList1)
            # print(tempList2)
            dataSetList.append(tempList1) 
            dataSetList.append(tempList2) 
        df = pd.DataFrame(dataSetList, columns = ['X', 'Y','Label'])
        return df


# datapoint = Dataset(10000) #10,000 data points
# datalist = datapoint.get(False)
# print(datalist)
# print(datapoint.get(True))

# import sys
# sys.path.insert(0,"/content/drive/MyDrive/Semester 5/ML/ML Assignment 2/utils.py")

from matplotlib import pyplot as plt
import seaborn as sns


datapoint = Dataset(10000) #10,000 data points
df = datapoint.get(False)

sns.scatterplot(x='X', y='Y', hue='Label', data=df, )
# Placing Legend outside the Figure
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.show()
df = df.iloc[1:, :]
print(len(df))

datapoint = Dataset(10000) #10,000 data points
df1 = datapoint.get(True)
df1 = df1.iloc[1:, :]


sns.scatterplot(x='X', y='Y', hue='Label', data=df1, )
# Placing Legend outside the Figure
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.show()

shuffled_df1 = df.sample(frac = 1, random_state = 50)
shuffled_df2 = df1.sample(frac = 1, random_state = 50)
#shuffling the dataset

"""####*Class* for PTA algorithm -> """

class Perceptron:
    def __init__(self,df):
        self.df = df

    def PTA1(self,x_train_num,y_train_num,len,a,x): #len is length of train
        w1 = 0
        w2 = 0
        b = 0
        iterationCount = 0
        while(1):
            iterationCount = iterationCount + 1
            updatedW1 = w1
            updatedW2 = w2
            updatedB = b
            for i in range(0,len):
                y_pred_value = b + w1*x_train_num[i][0] + w2*x_train_num[i][1]
                #comparing the true label and the prediction label
                if (y_pred_value < 0):
                    predictionLabel = 0
                else:
                    predictionLabel = 1
                
                updatedW1 = updatedW1 + a*(y_train_num[i] - predictionLabel)*x_train_num[i][0]
                updatedW2 = updatedW2 + a*(y_train_num[i] - predictionLabel)*x_train_num[i][1]
                updatedB = updatedB + a*(y_train_num[i] - predictionLabel)
            if updatedW1 == w1 and updatedW2 == w2 and updatedB == b or iterationCount > x:
                break;
            w1 = updatedW1
            w2 = updatedW2
            b = updatedB
        return w1,w2,b
    
    def PTA2(self,x_train_num,y_train_num,len,a,x): #len is length of train
        w1 = 0
        w2 = 0
        iterationCount = 0
        while(1):
            iterationCount = iterationCount + 1
            updatedW1 = w1
            updatedW2 = w2
            for i in range(0,len):
                y_pred_value = w1*x_train_num[i][0] + w2*x_train_num[i][1]
                #comparing the true label and the prediction label
                if (y_pred_value < 0):
                    predictionLabel = 0
                else:
                    predictionLabel = 1
                
                updatedW1 = updatedW1 + a*((y_train_num[i] - predictionLabel)*x_train_num[i][0])
                updatedW2 = updatedW2 + a*((y_train_num[i] - predictionLabel)*x_train_num[i][1])

            if updatedW1 == w1 and updatedW2 == w2 or iterationCount > x:
                break;
            w1 = updatedW1
            w2 = updatedW2
        return w1,w2

    def testing1(self,x_test_num,y_test_num,lent,w1,w2,b):
        count = 0
        for i in range(0,lent):
            if b + w1*x_test_num[i][0] + w2*x_test_num[i][1] < 0:
                predictionLabel = 0
            else:
                predictionLabel = 1
            if y_test_num[i] == predictionLabel:
                count = count + 1
        
        print("Accuracy of testing with bias is",(count/lent)*100)
    
    def testing2(self,x_test_num,y_test_num,lent,w1,w2):
        count = 0
        for i in range(0,lent):
            if w1*x_test_num[i][0] + w2*x_test_num[i][1] < 0:
                predictionLabel = 0
            else:
                predictionLabel = 1
            if y_test_num[i] == predictionLabel:
                count = count + 1
        
        print("Accuracy of testing with fixed bias as zero is",(count/lent)*100)
    
    def decision1(self,w1,w2,b):
        x1 = -2
        y1 = (-1* ((w1*x1) + b))/w2
        x2 = 2
        y2 = (-1* ((w1*x2) + b))/w2
        sns.scatterplot(x='X', y='Y', hue='Label', data = self.df, )
        plt.plot((x1,y1),(x2,y2))
        plt.legend(bbox_to_anchor=(1, 1), loc=2)
        plt.show()

    
    def decision2(self,w1,w2):
        x1 = -2
        y1 = (-1* (w1*x1))/w2
        x2 = 2
        y2 = (-1* (w1*x2))/w2
        sns.scatterplot(x='X', y='Y', hue='Label', data = self.df, )
        plt.plot((x1,y1),(x2,y2))
        plt.legend(bbox_to_anchor=(1, 1), loc=2)
        plt.show()

"""####PTA1 without *noise*"""

#Without noise
p = Perceptron(shuffled_df1)
train_df = shuffled_df1[:7000]
test_df = shuffled_df1[7000:]
train = train_df.to_numpy()
test = test_df.to_numpy()

x_train_num = train[:,0:2]
y_train_num = train[:,2]
x_test_num = test[:,0:2]
y_test_num = test[:,2]

w1,w2,b = p.PTA1(x_train_num,y_train_num,7000,0.01,8000)

print(w1)
print(w2)
print(b)
p.testing1(x_test_num,y_test_num,3000,w1,w2,b)
p.decision1(w1,w2,b)

"""####PTA1 with noise

```
# This is formatted as code
```


"""

p = Perceptron(shuffled_df2)
train_df = shuffled_df1[:7000]
test_df = shuffled_df1[7000:]
train = train_df.to_numpy()
test = test_df.to_numpy()

x_train_num = train[:,0:2]
y_train_num = train[:,2]
x_test_num = test[:,0:2]
y_test_num = test[:,2]

w1n,w2n,bn = p.PTA1(x_train_num,y_train_num,7000,0.01,8000)

print(w1n)
print(w2n)
print(bn)
p.testing1(x_test_num,y_test_num,3000,w1n,w2n,bn)
p.decision1(w1n,w2n,bn)

"""####PTA2, with fixed bias and without noise

> Indented block


"""

#Without noise
p = Perceptron(shuffled_df1)
train_df = shuffled_df1[:7000]
test_df = shuffled_df1[7000:]
train = train_df.to_numpy()
test = test_df.to_numpy()

x_train_num = train[:,0:2]
y_train_num = train[:,2]
x_test_num = test[:,0:2]
y_test_num = test[:,2]

w1,w2 = p.PTA2(x_train_num,y_train_num,7000,0.01,20000)

print(w1)
print(w2)
p.testing2(x_test_num,y_test_num,3000,w1,w2)
p.decision2(w1,w2)

"""####Part 5 : """